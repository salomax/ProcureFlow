# NeoTool Project Rules for Cursor AI

## Specification Knowledge Base

This project uses a comprehensive specification located in the `spec/` directory. **ALWAYS** reference the specification when:
- Creating new features
- Making architectural decisions
- Writing code that follows project patterns
- Understanding the technology stack
- Following coding conventions

### Key Specification Documents

1. **Start Here**: `spec/SPECIFICATION_MANIFEST.md` - Complete index of all specification documents
2. **Architecture**: `spec/ARCHITECTURE_OVERVIEW.md` - System architecture and technology stack
3. **Quick Reference**: `spec/QUICK_REFERENCE.md` - Common patterns, commands, and conventions
4. **Glossary**: `spec/GLOSSARY.md` - Terminology and definitions
5. **Project Setup**: `spec/PROJECT_SETUP.md` - Setup and configuration guide

### Architecture Decision Records (ADRs)

All major technical decisions are documented in `spec/adr/`:
- `spec/adr/0001-monorepo-architecture.md` - Monorepo structure
- `spec/adr/0002-containerized-architecture.md` - Containerization strategy
- `spec/adr/0003-kotlin-micronaut-backend.md` - Backend technology choices
- `spec/adr/0004-typescript-nextjs-frontend.md` - Frontend technology choices
- `spec/adr/0005-postgresql-database.md` - Database technology choices

### Service Layer Documentation

- `spec/service/graphql-federation-architecture.md` - GraphQL Federation patterns
- `spec/service/database-schema-organization.md` - Database schema rules
- `spec/service/kotlin/jpa-entity.md` - JPA entity patterns

### Frontend Documentation

- `spec/web/web-src-structure.md` - Frontend directory structure
- `spec/web/web-components.md` - Component system and patterns
- `spec/web/web-themes.md` - Theme system and design tokens
- `spec/web/web-graphql-operations.md` - GraphQL operations in frontend
- `spec/web/web-i18n-architecture.md` - Internationalization patterns
- `spec/web/web-custom-hooks.md` - Custom React hooks patterns

## Technology Stack

### Backend
- **Language**: Kotlin
- **Framework**: Micronaut
- **Build**: Gradle
- **API**: GraphQL (Apollo Federation)
- **Data Access**: Micronaut Data (JPA/Hibernate)
- **Database**: PostgreSQL 15+

### Frontend
- **Framework**: Next.js 14+ (App Router)
- **Language**: TypeScript
- **UI Library**: React 18+
- **Styling**: Material-UI + Custom Design System
- **API Client**: Apollo Client (GraphQL)
- **State**: React Context + Custom Hooks

### Infrastructure
- **Containers**: Docker
- **Orchestration**: Kubernetes
- **GitOps**: ArgoCD
- **Observability**: Prometheus, Grafana, Loki

## Development Guidelines

### When Creating New Features

1. **Reference the Specification**: Always check relevant spec documents before implementing
2. **Follow Architecture Patterns**: Use patterns documented in ADRs and architecture docs
3. **Maintain Type Safety**: Ensure end-to-end type safety from database to UI
4. **Follow Directory Structure**: Adhere to structure defined in `spec/web/web-src-structure.md` (frontend) and service docs (backend)
5. **Use GraphQL Federation**: Follow patterns in `spec/service/graphql-federation-architecture.md`
6. **Follow Component Patterns**: Use component system from `spec/web/web-components.md`
7. **Apply Theme System**: Use design tokens from `spec/web/web-themes.md`

### Code Generation Rules

- **Backend (Kotlin/Micronaut)**:
  - Follow clean architecture: API → Service → Repository → Entity
  - Use dependency injection (Micronaut)
  - Implement GraphQL resolvers following federation patterns
  - Use JPA entities following patterns in `spec/service/kotlin/jpa-entity.md`
  - Follow database schema organization from `spec/service/database-schema-organization.md`

- **Frontend (TypeScript/Next.js)**:
  - Use App Router structure (Next.js 14+)
  - Follow directory structure from `spec/web/web-src-structure.md`
  - Use components from design system (`spec/web/web-components.md`)
  - Apply theme tokens from `spec/web/web-themes.md`
  - Use GraphQL operations following `spec/web/web-graphql-operations.md`
  - Implement i18n following `spec/web/web-i18n-architecture.md`
  - Use custom hooks patterns from `spec/web/web-custom-hooks.md`

### GraphQL Development

- Use Apollo Federation for distributed GraphQL
- Follow federation patterns in `spec/service/graphql-federation-architecture.md`
- Generate TypeScript types from GraphQL schema
- Use code generation for type safety
- Reference `spec/contracts/graphql-federation.md` for contract details

### Database Development

- Follow schema organization from `spec/service/database-schema-organization.md`
- Use Flyway for migrations
- Follow JPA entity patterns from `spec/service/kotlin/jpa-entity.md`
- Maintain domain-driven design principles

## Project Structure

```
neotool/
├── service/          # Backend services (Kotlin/Micronaut)
│   ├── kotlin/      # Main service application
│   └── gateway/     # Apollo Router configuration
├── web/              # Web frontend (Next.js)
├── mobile/           # Mobile app (React Native/Expo)
├── infra/            # Infrastructure as Code
├── contracts/        # API contracts (GraphQL schemas)
└── spec/             # Specification and documentation (THIS IS THE KNOWLEDGE BASE)
```

## Important Patterns

### Monorepo Architecture
- Clear separation of concerns
- Shared contracts and design system
- Independent service deployment

### GraphQL Federation
- Distributed schema development
- Type composition across services
- Apollo Router as gateway

### Domain-Driven Design
- Domain entities, services, repositories
- Clear boundaries and testability

### Clean Architecture
- Layered architecture
- Separation of concerns
- Testability

### Component-Driven Development
- Atomic design system
- Reusable UI components
- Design consistency

## When Suggesting Solutions

1. **Always reference the spec**: Check `spec/` folder for relevant documentation
2. **Follow established patterns**: Use patterns from ADRs and architecture docs
3. **Maintain consistency**: Follow existing code structure and conventions
4. **Ensure type safety**: Maintain end-to-end type safety
5. **Consider architecture**: Respect the layered architecture and boundaries
6. **Use design system**: Apply components and themes from the design system
7. **Follow GraphQL patterns**: Use federation patterns for API development

## RAG Integration

The specification is optimized for RAG indexing with:
- YAML frontmatter metadata in all documents
- Cross-references between related documents
- Semantic tags for search
- Structured manifest for document discovery
- Clear hierarchy and categorization

When searching for information:
1. Start with `spec/SPECIFICATION_MANIFEST.md` for document discovery
2. Use `spec/ARCHITECTURE_OVERVIEW.md` for system understanding
3. Reference `spec/GLOSSARY.md` for terminology
4. Follow cross-references in documents for related context
5. Use category tags to find related documents

## Example: Creating a New Feature

When asked to create a new feature:

1. **Understand Requirements**: Review the feature request
2. **Check Specification**: Search `spec/` for relevant patterns and guidelines
3. **Follow Architecture**: Use patterns from architecture docs and ADRs
4. **Implement Backend** (if needed):
   - Create GraphQL schema in appropriate subgraph
   - Implement resolver following federation patterns
   - Create service layer following clean architecture
   - Add repository and entity following JPA patterns
   - Add database migration if needed
5. **Implement Frontend** (if needed):
   - Create components using design system
   - Use theme tokens for styling
   - Implement GraphQL operations
   - Add i18n support
   - Follow directory structure
6. **Ensure Type Safety**: Generate types and maintain end-to-end type safety
7. **Follow Testing Patterns**: Add appropriate tests

---

**Remember**: The `spec/` folder is the source of truth. Always reference it when making decisions or implementing features.

